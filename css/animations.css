// Animation Functionality

// Technology-inspired animations
document.addEventListener('DOMContentLoaded', () => {
  // Typing effect for hero title
  setTimeout(() => {
    const heroTitle = document.querySelector('.hero h2');
    if (heroTitle) {
      const originalText = heroTitle.textContent;
      heroTitle.textContent = '';
      heroTitle.style.borderRight = '3px solid var(--secondary)';
      
      let charIndex = 0;
      const typeText = () => {
        if (charIndex < originalText.length) {
          heroTitle.textContent += originalText.charAt(charIndex);
          charIndex++;
          setTimeout(typeText, 50);
        } else {
          heroTitle.style.borderRight = 'none';
        }
      };
      
      typeText();
    }
  }, 2000); // Start after loader disappears
  
  // Create floating elements in the hero background
  createFloatingElements();
  
  // Pulse effect for feature icons
  const featureIcons = document.querySelectorAll('.feature-icon');
  featureIcons.forEach((icon, index) => {
    icon.style.animationDelay = `${index * 0.2}s`;
    icon.style.animation = 'pulse 2s infinite';
  });
  
  // Add hover effect to buttons
  const buttons = document.querySelectorAll('.btn');
  buttons.forEach(btn => {
    btn.addEventListener('mouseenter', createRippleEffect);
  });
});

// Create ripple effect on button click
function createRippleEffect(e) {
  const button = e.currentTarget;
  
  // Remove any existing ripple elements
  const ripples = button.querySelectorAll('.ripple');
  ripples.forEach(ripple => ripple.remove());
  
  // Create ripple element
  const ripple = document.createElement('span');
  ripple.classList.add('ripple');
  button.appendChild(ripple);
  
  // Set ripple position
  const rect = button.getBoundingClientRect();
  const size = Math.max(rect.width, rect.height);
  ripple.style.width = ripple.style.height = `${size}px`;
  ripple.style.left = `${e.clientX - rect.left - size / 2}px`;
  ripple.style.top = `${e.clientY - rect.top - size / 2}px`;
  
  // Remove ripple after animation completes
  setTimeout(() => {
    ripple.remove();
  }, 700);
}

// Create floating technology-inspired elements
function createFloatingElements() {
  const heroSection = document.querySelector('.hero');
  if (!heroSection) return;
  
  const numElements = 10;
  
  for (let i = 0; i < numElements; i++) {
    // Create floating element
    const floatingEl = document.createElement('div');
    floatingEl.classList.add('floating-tech-element');
    
    // Random size between 10px and 30px
    const size = Math.floor(Math.random() * 20) + 10;
    floatingEl.style.width = `${size}px`;
    floatingEl.style.height = `${size}px`;
    
    // Random position
    const left = Math.floor(Math.random() * 100);
    const top = Math.floor(Math.random() * 100);
    floatingEl.style.left = `${left}%`;
    floatingEl.style.top = `${top}%`;
    
    // Random shape
    const shapes = ['circle', 'square', 'triangle'];
    const shape = shapes[Math.floor(Math.random() * shapes.length)];
    floatingEl.classList.add(`shape-${shape}`);
    
    // Random animation duration between 10s and 20s
    const duration = Math.floor(Math.random() * 10) + 10;
    floatingEl.style.animationDuration = `${duration}s`;
    
    // Random delay
    const delay = Math.floor(Math.random() * 5);
    floatingEl.style.animationDelay = `${delay}s`;
    
    // Append to hero section
    heroSection.appendChild(floatingEl);
  }
}

// Scale effect on scroll for section headings
window.addEventListener('scroll', () => {
  const headings = document.querySelectorAll('.section-heading h2');
  
  headings.forEach(heading => {
    const position = heading.getBoundingClientRect();
    
    // Calculate how far the element is from the top of the viewport
    const distanceFromTop = position.top;
    const windowHeight = window.innerHeight;
    
    // If element is in viewport
    if (distanceFromTop > 0 && distanceFromTop < windowHeight) {
      // Calculate a scale value between 0.9 and 1.1 based on element position
      const scrollProgress = 1 - (distanceFromTop / windowHeight);
      const scale = 0.9 + Math.min(scrollProgress * 0.2, 0.2);
      
      // Apply transform
      heading.style.transform = `scale(${scale})`;
    }
  });
});

// Parallax effect for images
document.addEventListener('scroll', () => {
  const parallaxElements = document.querySelectorAll('.sobre-image img, .hero-image img');
  
  parallaxElements.forEach(element => {
    const position = element.getBoundingClientRect();
    const speed = 0.05;
    
    // If element is in viewport
    if (position.top < window.innerHeight && position.bottom > 0) {
      const yScroll = window.scrollY;
      const yPos = -(yScroll * speed);
      
      element.style.transform = `translateY(${yPos}px)`;
    }
  });
});

// Add CSS for tech element animations
(function addTechElementStyles() {
  const styleSheet = document.createElement('style');
  styleSheet.innerText = `
    .floating-tech-element {
      position: absolute;
      z-index: 1;
      opacity: 0.2;
      animation: float-around linear infinite;
    }
    
    .shape-circle {
      border-radius: 50%;
      background: var(--secondary);
    }
    
    .shape-square {
      background: var(--white);
    }
    
    .shape-triangle {
      width: 0 !important;
      height: 0 !important;
      border-left: 10px solid transparent;
      border-right: 10px solid transparent;
      border-bottom: 17px solid var(--secondary);
    }
    
    @keyframes float-around {
      0% {
        transform: translate(0, 0) rotate(0deg);
      }
      25% {
        transform: translate(50px, 25px) rotate(90deg);
      }
      50% {
        transform: translate(0, 50px) rotate(180deg);
      }
      75% {
        transform: translate(-50px, 25px) rotate(270deg);
      }
      100% {
        transform: translate(0, 0) rotate(360deg);
      }
    }
    
    .ripple {
      position: absolute;
      border-radius: 50%;
      background-color: rgba(255, 255, 255, 0.5);
      transform: scale(0);
      animation: ripple 0.7s linear;
      pointer-events: none;
    }
    
    @keyframes ripple {
      to {
        transform: scale(2);
        opacity: 0;
      }
    }
  `;
  document.head.appendChild(styleSheet);
})();